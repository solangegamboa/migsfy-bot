#!/usr/bin/env python

import slskd_api
import time
import re
import sys
import os
from difflib import SequenceMatcher

try:
    import music_tag
    MUSIC_TAG_AVAILABLE = True
    print("‚úÖ music_tag dispon√≠vel para melhorar nomes de arquivos")
except ImportError:
    MUSIC_TAG_AVAILABLE = False
    print("‚ö†Ô∏è music_tag n√£o encontrado - usando nomes originais")
    print("üí° Instale com: pip install music-tag")


def connectToSlskd():
    try:
        slskd = slskd_api.SlskdClient(host='192.168.15.100', api_key='ffa07bf8-3a02-4fbc-8be3-5618f58f1d5e', url_base='http://192.168.15.100:5030')
        app_state = slskd.application.state()
        print("‚úÖ Conectado com sucesso ao slskd!")
        return slskd
    except Exception as e:
        print(f"‚ùå Falha ao conectar: {e}")
        return None


def extract_artist_and_song(search_text):
    """Extrai artista e m√∫sica do texto de busca"""
    separators = [' - ', ' ‚Äì ', ' ‚Äî ', ': ', ' | ', ' by ']
    
    for sep in separators:
        if sep in search_text:
            parts = search_text.split(sep, 1)
            if len(parts) == 2:
                artist = parts[0].strip()
                song = parts[1].strip()
                return artist, song
    
    return search_text.strip(), ""


def create_search_variations(search_text):
    """Cria varia√ß√µes de busca priorizando m√∫sica sem artista primeiro"""
    artist, song = extract_artist_and_song(search_text)
    
    variations = []
    
    if artist and song:
        # PRIORIDADE 1: Busca apenas pela m√∫sica (mais resultados)
        variations.extend([
            f"{song} *.mp3",                    # S√≥ a m√∫sica
            f"{song} *.mp3 -flac -wav",         # S√≥ a m√∫sica, excluindo lossless
            f'"{song}" *.mp3',                  # M√∫sica exata
            f"*{song[:4]}* *.mp3",              # Wildcard no in√≠cio da m√∫sica
        ])
        
        # PRIORIDADE 2: Busca com artista (mais espec√≠fico)
        variations.extend([
            f"{artist} {song} *.mp3",           # Artista + m√∫sica
            f"{song} {artist} *.mp3",           # M√∫sica + artista
            f"{artist} {song} -flac -wav",      # Com exclus√µes
            f'"{artist}" "{song}" *.mp3',       # Termos exatos
        ])
    else:
        # Para buscas simples, tamb√©m prioriza busca ampla
        variations.extend([
            f"{search_text} *.mp3",             # Busca b√°sica
            f"{search_text} *.mp3 -flac -wav",  # Com exclus√µes
            f'"{search_text}" *.mp3',           # Termo exato
            f"*{search_text[:4]}* *.mp3",       # Wildcard no in√≠cio
        ])
    
    # Remove duplicatas e limita
    seen = set()
    unique_variations = []
    for var in variations:
        if var and var not in seen and len(var.strip()) > 0:
            seen.add(var)
            unique_variations.append(var)
    
    return unique_variations[:8]  # Mant√©m 8 varia√ß√µes eficientes


def calculate_similarity(search_text, filename):
    """Calcula similaridade entre busca e nome do arquivo"""
    search_normalized = re.sub(r'[^\w\s]', '', search_text.lower())
    filename_normalized = re.sub(r'[^\w\s]', '', filename.lower())
    similarity = SequenceMatcher(None, search_normalized, filename_normalized).ratio()
    return similarity


def score_mp3_file(file_info, search_text):
    """Pontua arquivo MP3 baseado em crit√©rios de qualidade"""
    filename = file_info.get('filename', '')
    size = file_info.get('size', 0)
    bitrate = file_info.get('bitRate', 0)
    
    # FILTRO OBRIGAT√ìRIO: Apenas MP3
    if not filename.lower().endswith('.mp3'):
        return 0
    
    # Pontua√ß√£o base por similaridade
    similarity_score = calculate_similarity(search_text, filename) * 100
    
    # B√¥nus por qualidade de √°udio
    quality_bonus = 0
    if bitrate >= 320:
        quality_bonus = 30
    elif bitrate >= 256:
        quality_bonus = 25
    elif bitrate >= 192:
        quality_bonus = 20
    elif bitrate >= 128:
        quality_bonus = 15
    elif bitrate > 0:
        quality_bonus = 10
    
    # B√¥nus por tamanho adequado
    size_bonus = 0
    if 2000000 <= size <= 15000000:  # 2-15MB
        size_bonus = 15
    elif 1000000 <= size <= 20000000:  # 1-20MB
        size_bonus = 10
    elif size >= 500000:  # Pelo menos 500KB
        size_bonus = 5
    
    # Penalidades
    penalty = 0
    filename_lower = filename.lower()
    bad_words = ['sample', 'preview', 'demo', 'test', 'snippet']
    if any(word in filename_lower for word in bad_words):
        penalty = -30
    
    total_score = similarity_score + quality_bonus + size_bonus + penalty
    return max(0, total_score)


def find_best_mp3(search_responses, search_text):
    """Encontra o melhor arquivo MP3"""
    best_file = None
    best_score = 0
    best_user = None
    
    total_files = 0
    mp3_files = 0
    
    for response in search_responses:
        username = response.get('username', '')
        files = response.get('files', [])
        
        for file_info in files:
            total_files += 1
            filename = file_info.get('filename', '')
            
            if not filename.lower().endswith('.mp3'):
                continue
                
            mp3_files += 1
            score = score_mp3_file(file_info, search_text)
            
            if score > best_score:
                best_score = score
                best_file = file_info
                best_user = username
    
    print(f"üìä Arquivos analisados: {total_files} | MP3s: {mp3_files}")
    
    return best_file, best_user, best_score


def check_user_online(slskd, username):
    """Verifica se o usu√°rio est√° online/conectado"""
    try:
        # Tenta obter informa√ß√µes do usu√°rio
        user_info = slskd.users.get(username)
        
        # Verifica status de conex√£o
        status = user_info.get('status', '').lower()
        is_online = status in ['online', 'away'] or user_info.get('isOnline', False)
        
        if is_online:
            print(f"‚úÖ Usu√°rio {username} est√° online")
            return True
        else:
            print(f"‚ùå Usu√°rio {username} est√° offline (status: {status})")
            return False
            
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao verificar usu√°rio {username}: {e}")
        # Se n√£o conseguir verificar, assume que pode tentar
        print(f"ü§î Tentando download mesmo assim...")
        return True


def get_user_browse_info(slskd, username):
    """Obt√©m informa√ß√µes de browse do usu√°rio para verificar conectividade"""
    try:
        # Tenta fazer browse do usu√°rio (mais confi√°vel que status)
        browse_result = slskd.users.browse(username)
        
        if browse_result and 'directories' in browse_result:
            print(f"‚úÖ Usu√°rio {username} respondeu ao browse - est√° ativo")
            return True
        else:
            print(f"‚ùå Usu√°rio {username} n√£o respondeu ao browse")
            return False
            
    except Exception as e:
        print(f"‚ö†Ô∏è Browse falhou para {username}: {e}")
        return False


def download_mp3(slskd, username, filename, file_size=0):
    """Inicia download do MP3 com verifica√ß√£o de usu√°rio online"""
    try:
        print(f"üîç Verificando conectividade do usu√°rio {username}...")
        
        # Primeira verifica√ß√£o: status do usu√°rio
        user_online = check_user_online(slskd, username)
        
        if not user_online:
            print(f"‚ö†Ô∏è Usu√°rio parece offline, tentando browse para confirmar...")
            # Segunda verifica√ß√£o: browse do usu√°rio
            browse_ok = get_user_browse_info(slskd, username)
            
            if not browse_ok:
                print(f"‚ùå Usu√°rio {username} n√£o est√° respondendo - pulando download")
                return False
        
        print(f"üì• Iniciando download de: {os.path.basename(filename)}")
        
        # Formato correto da API slskd: lista de dicion√°rios com filename e size
        file_dict = {
            'filename': filename,
            'size': file_size
        }
        
        slskd.transfers.enqueue(username, [file_dict])
        print(f"‚úÖ Download enfileirado com sucesso!")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro no download: {e}")
        
        # Tenta sintaxe alternativa apenas se usu√°rio estiver online
        if user_online:
            try:
                # Tenta com par√¢metros nomeados
                slskd.transfers.enqueue(username=username, files=[file_dict])
                print(f"‚úÖ Download enfileirado (sintaxe alternativa)!")
                return True
            except Exception as e2:
                print(f"‚ùå Erro na sintaxe alternativa: {e2}")
        
        return False


def wait_for_search_completion(slskd, search_id, max_wait=30, check_interval=2):
    """Aguarda a busca finalizar completamente"""
    print(f"‚è≥ Aguardando finaliza√ß√£o da busca (m√°x {max_wait}s)...")
    
    start_time = time.time()
    last_response_count = 0
    stable_count = 0
    
    while time.time() - start_time < max_wait:
        try:
            search_responses = slskd.searches.search_responses(search_id)
            current_count = len(search_responses)
            
            print(f"üìä Respostas: {current_count} (+{current_count - last_response_count})")
            
            # Se o n√∫mero de respostas n√£o mudou, incrementa contador de estabilidade
            if current_count == last_response_count:
                stable_count += 1
            else:
                stable_count = 0
                last_response_count = current_count
            
            # Se ficou est√°vel por 3 verifica√ß√µes consecutivas, considera finalizada
            if stable_count >= 3 and current_count > 0:
                print(f"‚úÖ Busca estabilizada com {current_count} respostas")
                return search_responses
            
            time.sleep(check_interval)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao verificar busca: {e}")
            time.sleep(check_interval)
    
    # Timeout - retorna o que conseguiu coletar
    final_responses = slskd.searches.search_responses(search_id)
    print(f"‚è∞ Timeout - coletadas {len(final_responses)} respostas")
    return final_responses


def find_alternative_users(search_responses, target_filename, original_user):
    """Encontra usu√°rios alternativos que t√™m o mesmo arquivo"""
    alternatives = []
    
    for response in search_responses:
        username = response.get('username', '')
        if username == original_user:
            continue
            
        files = response.get('files', [])
        for file_info in files:
            filename = file_info.get('filename', '')
            
            # Verifica se √© o mesmo arquivo (nome similar)
            if (filename.lower().endswith('.mp3') and 
                os.path.basename(filename).lower() == os.path.basename(target_filename).lower()):
                
                alternatives.append({
                    'username': username,
                    'file_info': file_info,
                    'similarity': calculate_similarity(target_filename, filename)
                })
    
    # Ordena por similaridade
    alternatives.sort(key=lambda x: x['similarity'], reverse=True)
    return alternatives[:3]  # Retorna at√© 3 alternativas


def smart_download_with_fallback(slskd, search_responses, best_file, best_user, search_query):
    """Tenta download inteligente com fallback para usu√°rios alternativos"""
    filename = best_file.get('filename')
    file_size = best_file.get('size', 0)
    
    print(f"\nüéØ Tentando download inteligente...")
    print(f"   üìÑ Arquivo: {os.path.basename(filename)}")
    print(f"   üë§ Usu√°rio principal: {best_user}")
    
    # Tenta download com usu√°rio principal
    success = download_mp3(slskd, best_user, filename, file_size)
    if success:
        return True
    
    # Se falhou, busca usu√°rios alternativos
    print(f"\nüîÑ Buscando usu√°rios alternativos...")
    alternatives = find_alternative_users(search_responses, filename, best_user)
    
    if not alternatives:
        print(f"‚ùå Nenhum usu√°rio alternativo encontrado")
        return False
    
    print(f"üìã Encontrados {len(alternatives)} usu√°rios alternativos:")
    
    for i, alt in enumerate(alternatives, 1):
        alt_user = alt['username']
        alt_file = alt['file_info']
        alt_filename = alt_file.get('filename')
        alt_size = alt_file.get('size', 0)
        similarity = alt['similarity']
        
        print(f"\nüìç Alternativa {i}: {alt_user}")
        print(f"   üìÑ Arquivo: {os.path.basename(alt_filename)}")
        print(f"   üíæ Tamanho: {alt_size / 1024 / 1024:.2f} MB")
        print(f"   üéß Bitrate: {alt_file.get('bitRate', 0)} kbps")
        print(f"   üéØ Similaridade: {similarity:.1f}%")
        
        # Tenta download com usu√°rio alternativo
        success = download_mp3(slskd, alt_user, alt_filename, alt_size)
        if success:
            print(f"‚úÖ Sucesso com usu√°rio alternativo: {alt_user}")
            return True
        else:
            print(f"‚ùå Falhou com {alt_user}, tentando pr√≥ximo...")
    
    print(f"‚ùå Todos os usu√°rios alternativos falharam")
    return False
    """Melhora o nome do arquivo usando tags de metadados"""
    if not MUSIC_TAG_AVAILABLE or not os.path.exists(file_path):
        return file_path
    
    try:
        # L√™ as tags do arquivo
        audio_file = music_tag.load_file(file_path)
        
        # Extrai informa√ß√µes das tags
        artist = str(audio_file.get('artist', '')).strip()
        title = str(audio_file.get('title', '')).strip()
        album = str(audio_file.get('album', '')).strip()
        year = str(audio_file.get('year', '')).strip()
        track = str(audio_file.get('tracknumber', '')).strip()
        
        # Remove caracteres inv√°lidos para nomes de arquivo
        def clean_filename(text):
            if not text:
                return ""
            # Remove caracteres problem√°ticos
            cleaned = re.sub(r'[<>:"/\\|?*]', '', text)
            # Remove espa√ßos extras
            cleaned = re.sub(r'\s+', ' ', cleaned).strip()
            return cleaned
        
        # Constr√≥i novo nome baseado nas tags dispon√≠veis
        new_name_parts = []
        
        if artist and title:
            # Formato: Artista - T√≠tulo
            new_name_parts.append(f"{clean_filename(artist)} - {clean_filename(title)}")
        elif title:
            # Apenas t√≠tulo
            new_name_parts.append(clean_filename(title))
        elif artist:
            # Apenas artista
            new_name_parts.append(clean_filename(artist))
        
        # Adiciona informa√ß√µes extras se dispon√≠veis
        extras = []
        if album and album.lower() not in (artist.lower() if artist else ""):
            extras.append(f"[{clean_filename(album)}]")
        if year and len(year) == 4:
            extras.append(f"({year})")
        if track and track.isdigit():
            extras.append(f"#{track.zfill(2)}")
        
        if extras:
            new_name_parts.extend(extras)
        
        # Se n√£o conseguiu extrair informa√ß√µes √∫teis, mant√©m nome original
        if not new_name_parts:
            print(f"‚ö†Ô∏è Sem tags √∫teis encontradas - mantendo nome original")
            return file_path
        
        # Constr√≥i o novo nome
        base_dir = os.path.dirname(file_path)
        file_ext = os.path.splitext(file_path)[1]
        new_filename = " ".join(new_name_parts) + file_ext
        new_path = os.path.join(base_dir, new_filename)
        
        # Evita sobrescrever arquivos existentes
        counter = 1
        while os.path.exists(new_path) and new_path != file_path:
            name_without_ext = " ".join(new_name_parts)
            new_filename = f"{name_without_ext} ({counter}){file_ext}"
            new_path = os.path.join(base_dir, new_filename)
            counter += 1
        
        # Renomeia o arquivo se necess√°rio
        if new_path != file_path:
            os.rename(file_path, new_path)
            print(f"üìù Arquivo renomeado:")
            print(f"   De: {os.path.basename(file_path)}")
            print(f"   Para: {os.path.basename(new_path)}")
            return new_path
        else:
            print(f"‚úÖ Nome do arquivo j√° est√° adequado")
            return file_path
            
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao processar tags: {e}")
        return file_path




def cleanup_search(slskd, search_id):
    """Remove busca finalizada para liberar recursos"""
    try:
        slskd.searches.delete(search_id)
        print(f"üßπ Busca {search_id} removida")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao remover busca: {e}")


def smart_mp3_search(slskd, query):
    """Busca inteligente por MP3 com m√∫ltiplas varia√ß√µes"""
    print(f"üéØ Busca inteligente por MP3: '{query}'")
    
    artist, song = extract_artist_and_song(query)
    if artist and song:
        print(f"üé§ Artista: '{artist}' | üéµ M√∫sica: '{song}'")
    
    variations = create_search_variations(query)
    print(f"üìù {len(variations)} varia√ß√µes criadas")
    
    for i, search_term in enumerate(variations, 1):
        print(f"\nüìç Tentativa {i}/{len(variations)}: '{search_term}'")
        
        # Executa a busca e verifica quantos arquivos encontrou
        try:
            print(f"üîç Buscando: '{search_term}'")
            
            search_result = slskd.searches.search_text(search_term)
            search_id = search_result.get('id')
            
            # Aguarda a busca finalizar completamente
            search_responses = wait_for_search_completion(slskd, search_id, max_wait=25)
            
            if not search_responses:
                print("‚ùå Nenhuma resposta")
                continue
            
            # Conta total de arquivos encontrados
            total_files = sum(len(response.get('files', [])) for response in search_responses)
            
            print(f"üìä Total de arquivos encontrados: {total_files}")
            
            # Se encontrou mais de 50 arquivos, processa e para
            if total_files > 50:
                print(f"üéØ Encontrados {total_files} arquivos (>50) - processando resultados...")
                
                best_file, best_user, best_score = find_best_mp3(search_responses, query)
                
                if best_file and best_score > 15:
                    print(f"\nüéµ Melhor MP3 (score: {best_score:.1f}):")
                    print(f"   üë§ Usu√°rio: {best_user}")
                    print(f"   üìÑ Arquivo: {best_file.get('filename')}")
                    print(f"   üíæ Tamanho: {best_file.get('size', 0) / 1024 / 1024:.2f} MB")
                    print(f"   üéß Bitrate: {best_file.get('bitRate', 0)} kbps")
                    
                    # Usa download inteligente com fallback
                    success = smart_download_with_fallback(slskd, search_responses, best_file, best_user, query)
                    if success:
                        print(f"‚úÖ Sucesso com '{search_term}' ({total_files} arquivos)!")
                        return True
                    else:
                        print(f"‚ùå Falha no download ap√≥s tentar todas as alternativas")
                        return False
                else:
                    print(f"‚ùå Nenhum MP3 adequado (melhor score: {best_score:.1f})")
                    return False
            
            # Se encontrou poucos arquivos, continua com pr√≥xima varia√ß√£o
            else:
                best_file, best_user, best_score = find_best_mp3(search_responses, query)
                
                if best_file and best_score > 15:
                    print(f"\nüéµ Melhor MP3 (score: {best_score:.1f}):")
                    print(f"   üë§ Usu√°rio: {best_user}")
                    print(f"   üìÑ Arquivo: {best_file.get('filename')}")
                    print(f"   üíæ Tamanho: {best_file.get('size', 0) / 1024 / 1024:.2f} MB")
                    print(f"   üéß Bitrate: {best_file.get('bitRate', 0)} kbps")
                    
                    # Usa download inteligente com fallback
                    success = smart_download_with_fallback(slskd, search_responses, best_file, best_user, query)
                    if success:
                        print(f"‚úÖ Sucesso com '{search_term}'!")
                        return True
                    else:
                        print(f"‚ùå Falha no download - continuando...")
                else:
                    print(f"‚ùå Nenhum MP3 adequado (score: {best_score:.1f}) - continuando...")
                
        except Exception as e:
            print(f"‚ùå Erro na busca: {e}")
        
        # Pausa maior entre buscas para evitar sobrecarga
        if i < len(variations):
            print("‚è∏Ô∏è Pausa entre buscas...")
            time.sleep(3)
    
    return False


def manual_cleanup_downloads(slskd):
    """Fun√ß√£o para limpeza manual imediata dos downloads completados"""
    try:
        print("üßπ LIMPEZA MANUAL DE DOWNLOADS COMPLETADOS")
        print("=" * 50)
        
        # Mostra status atual
        downloads = slskd.transfers.get_all_downloads()
        print(f"üìä Downloads na fila: {len(downloads)}")
        
        completed_downloads = []
        active_downloads = []
        
        for download in downloads:
            state = download.get('state', '').lower()
            filename = download.get('filename', '')
            username = download.get('username', '')
            
            if state in ['completed', 'complete', 'finished']:
                completed_downloads.append({
                    'filename': os.path.basename(filename),
                    'username': username,
                    'state': state
                })
            else:
                active_downloads.append({
                    'filename': os.path.basename(filename),
                    'username': username,
                    'state': state
                })
        
        print(f"‚úÖ Downloads completados: {len(completed_downloads)}")
        print(f"‚è≥ Downloads ativos: {len(active_downloads)}")
        
        if completed_downloads:
            print(f"\nüìã DOWNLOADS COMPLETADOS PARA REMOVER:")
            for i, download in enumerate(completed_downloads, 1):
                print(f"   {i}. {download['filename']} (de {download['username']})")
            
            # Remove downloads completados
            removed_count = slskd.transfers.remove_completed_downloads()
            print(f"\nüéâ {len(completed_downloads)} downloads completados removidos!")
        else:
            print(f"\n‚ÑπÔ∏è Nenhum download completado para remover")
        
        if active_downloads:
            print(f"\n‚è≥ DOWNLOADS AINDA ATIVOS:")
            for i, download in enumerate(active_downloads, 1):
                print(f"   {i}. {download['filename']} - {download['state']} (de {download['username']})")
        
        return len(completed_downloads)
        
    except Exception as e:
        print(f"‚ùå Erro na limpeza manual: {e}")
        return 0


def show_downloads(slskd):
    """Mostra downloads ativos com op√ß√£o de limpeza"""
    try:
        print(f"\n{'='*50}")
        print("üì• Downloads ativos:")
        
        downloads = slskd.transfers.get_all_downloads()
        if downloads:
            completed_count = 0
            for i, download in enumerate(downloads, 1):
                filename = download.get('filename', 'N/A')
                state = download.get('state', 'N/A')
                username = download.get('username', 'N/A')
                
                if state.lower() in ['completed', 'complete', 'finished']:
                    completed_count += 1
                    print(f"   {i}. ‚úÖ {os.path.basename(filename)}")
                else:
                    print(f"   {i}. ‚è≥ {os.path.basename(filename)}")
                print(f"      üë§ De: {username} | Estado: {state}")
            
            if completed_count > 0:
                print(f"\nüí° {completed_count} downloads completados podem ser removidos")
                print(f"   Use a fun√ß√£o manual_cleanup_downloads() para limpar")
        else:
            print("   Nenhum download ativo")
    except Exception as e:
        print(f"‚ùå Erro ao listar downloads: {e}")


def main():
    print("üéµ SLSKD MP3 Search & Download Tool")
    print("üí° Uso: python3 slskd-mp3-search.py [\"artista - m√∫sica\"]")
    print()
    
    slskd = connectToSlskd()
    if not slskd:
        return
    
    if len(sys.argv) > 1:
        # Busca personalizada
        custom_query = ' '.join(sys.argv[1:])
        print(f"üéØ Iniciando busca por: '{custom_query}'")
        
        success = smart_mp3_search(slskd, custom_query)
        
        if success:
            show_downloads(slskd)
            print(f"\n‚úÖ Busca conclu√≠da com sucesso!")
            print(f"üí° Para limpar downloads completados manualmente, use manual_cleanup_downloads()")
        else:
            print(f"\n‚ùå Nenhum MP3 adequado encontrado")
    else:
        # Buscas de teste
        test_queries = [
            "In the end Linkin Park",
        ]
        
        print("üß™ Modo teste - buscando MP3s...")
        
        for query in test_queries:
            print(f"\n{'='*50}")
            success = smart_mp3_search(slskd, query)
            
            if success:
                print(f"‚úÖ Teste bem-sucedido com '{query}'")
                break
            else:
                print(f"‚ùå Teste falhou com '{query}'")
            
            time.sleep(2)
        
        show_downloads(slskd)


if __name__ == "__main__":
    main()
